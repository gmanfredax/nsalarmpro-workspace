/*
 * zone_monitor.c
 *
 *  Created on: Oct 26, 2025
 *      Author: gabriele
 */


#include "zone_monitor.h"
#include "main.h"

#include <math.h>
#include <stddef.h>
#include <string.h>

#ifndef ZONE_R_NORMAL_OHM
#define ZONE_R_NORMAL_OHM      4700.0f
#endif
#ifndef ZONE_R_ALARM_OHM
#define ZONE_R_ALARM_OHM       2200.0f
#endif
#ifndef ZONE_R_TAMPER_OHM
#define ZONE_R_TAMPER_OHM      8200.0f
#endif
#ifndef ZONE_R_EOL_SERIES_OHM
#define ZONE_R_EOL_SERIES_OHM  4700.0f
#endif

#define ZONE_SHORT_THRESHOLD_OHM 1000.0f
#define ZONE_OPEN_THRESHOLD_OHM  20000.0f

#define ZONE_TOL_NORMAL   0.20f
#define ZONE_TOL_ALARM    0.20f
#define ZONE_TOL_TAMPER   0.15f
#define ZONE_TOL_EOL1     0.20f

#define ZONE_HYSTERESIS_PCT 0.12f
#define ZONE_DEBOUNCE_MS    150u

#define ADC_CHANNEL_COUNT 11u
#define ADC_SAMPLE_COUNT  16u

#define ADC_INDEX_VBIAS 8u
#define ADC_INDEX_TEMP  9u
#define ADC_INDEX_VREF  10u

#define ZONE_EVENT_QUEUE_SIZE 8u

#ifndef TEMP_SENSOR_V25
#define TEMP_SENSOR_V25   1.43f
#endif
#ifndef TEMP_SENSOR_SLOPE
#define TEMP_SENSOR_SLOPE 0.0043f
#endif

#ifndef ZONE_LED_SHORT_BLINK_MS
#define ZONE_LED_SHORT_BLINK_MS 120u
#endif
#ifndef ZONE_LED_SHORT_PAUSE_MS
#define ZONE_LED_SHORT_PAUSE_MS 120u
#endif
#ifndef ZONE_LED_LONG_BLINK_MS
#define ZONE_LED_LONG_BLINK_MS 400u
#endif
#ifndef ZONE_LED_AFTER_PAUSE_MS
#define ZONE_LED_AFTER_PAUSE_MS 250u
#endif

typedef struct {
    zone_state_t physical_state;
    zone_state_t reported_state;
    zone_state_t pending_state;
    uint32_t pending_since;
    uint16_t raw_adc;
    float rloop_ohm;
    bool present;
} zone_runtime_t;

typedef struct {
    zone_state_t state;
    float center_ohm;
    float tolerance;
} zone_band_t;

static ADC_HandleTypeDef *s_adc_handle = NULL;
static uint16_t s_adc_buffer[ADC_CHANNEL_COUNT * ADC_SAMPLE_COUNT];
static uint16_t s_adc_average[ADC_CHANNEL_COUNT];
static volatile bool s_adc_ready = false;

static zone_cfg_t s_cfg = {
    .mode = ZONE_MODE_EOL2,
    .contact = ZONE_CONTACT_NC,
};

static zone_runtime_t s_zones[ZONE_MONITOR_ZONE_COUNT];

static uint8_t s_alarm_bitmap = 0u;
static uint8_t s_short_bitmap = 0u;
static uint8_t s_open_bitmap = 0u;
static uint8_t s_tamper_bitmap = 0u;
static uint8_t s_present_bitmap = 0u;
static uint8_t s_legacy_bitmap = 0u;

static float s_vdda = 3.30f;
static float s_vbias = 0.0f;
static float s_temperature_c = 25.0f;
static bool s_vbias_warning = false;

static zone_event_t s_event_queue[ZONE_EVENT_QUEUE_SIZE];
static uint8_t s_event_head = 0u;
static uint8_t s_event_tail = 0u;
static uint8_t s_event_seq = 0u;

extern void Error_Handler(void);

static void zone_monitor_reset_states(void);
static void zone_monitor_push_event(const zone_event_t *event);
static zone_state_t zone_monitor_classify(zone_state_t previous, float rloop, bool fault_short, bool fault_open, float vz, float vbias);
static zone_state_t zone_monitor_classify_eol1(zone_state_t previous, float rloop, bool fault_short, bool fault_open);
static zone_state_t zone_monitor_classify_banded(zone_state_t previous, float rloop, bool fault_short, bool fault_open);
static const zone_band_t *zone_monitor_get_bands(size_t *count);
static void zone_monitor_recompute_bitmaps(void);
static void zone_monitor_handle_state_update(uint8_t zone_id, uint32_t now_ms, float vz, bool fault_short, bool fault_open, float rloop, uint16_t raw);
static void zone_monitor_compute_measurements(uint32_t now_ms);
static void zone_monitor_blink_mode(zone_mode_t mode, zone_contact_t contact);
static zone_state_t zone_monitor_apply_contact(zone_state_t physical);

static bool queue_is_empty(void)
{
    return s_event_head == s_event_tail;
}

static uint8_t queue_increment(uint8_t index)
{
    return (uint8_t)((index + 1u) % ZONE_EVENT_QUEUE_SIZE);
}

void zone_monitor_configure(const zone_cfg_t *cfg)
{
    if (cfg == NULL) {
        return;
    }
    s_cfg = *cfg;
    zone_monitor_reset_states();
}

void zone_monitor_apply_cfg_from_dip(void)
{
    uint8_t mode_bit0 = (HAL_GPIO_ReadPin(DIP_MODE0_GPIO_Port, DIP_MODE0_Pin) == GPIO_PIN_RESET) ? 1u : 0u;
    uint8_t mode_bit1 = (HAL_GPIO_ReadPin(DIP_MODE1_GPIO_Port, DIP_MODE1_Pin) == GPIO_PIN_RESET) ? 1u : 0u;
    uint8_t mode_value = (uint8_t)((mode_bit1 << 1) | mode_bit0);

    zone_mode_t mode = ZONE_MODE_EOL2;
    switch (mode_value) {
    case 0u:
        mode = ZONE_MODE_EOL1_SERIE;
        break;
    case 1u:
        mode = ZONE_MODE_EOL2;
        break;
    case 2u:
        mode = ZONE_MODE_EOL3;
        break;
    default:
        mode = ZONE_MODE_EOL2;
        break;
    }

    uint8_t contact_bit = (HAL_GPIO_ReadPin(DIP_CONTACT_GPIO_Port, DIP_CONTACT_Pin) == GPIO_PIN_RESET) ? 1u : 0u;
    zone_contact_t contact = (contact_bit != 0u) ? ZONE_CONTACT_NO : ZONE_CONTACT_NC;

    zone_cfg_t cfg = {
        .mode = mode,
        .contact = contact,
    };

    zone_monitor_configure(&cfg);
    zone_monitor_blink_mode(mode, contact);
}

void zone_monitor_init(ADC_HandleTypeDef *hadc)
{
    s_adc_handle = hadc;
    if (s_adc_handle == NULL) {
        return;
    }

    if (HAL_ADCEx_Calibration_Start(s_adc_handle) != HAL_OK) {
        Error_Handler();
    }

    SET_BIT(s_adc_handle->Instance->CR2, ADC_CR2_TSVREFE);
    HAL_Delay(1);

    if (HAL_ADC_Start_DMA(s_adc_handle, (uint32_t *)s_adc_buffer, ADC_CHANNEL_COUNT * ADC_SAMPLE_COUNT) != HAL_OK) {
        Error_Handler();
    }
}

void zone_monitor_task(uint32_t now_ms)
{
    if (!s_adc_ready) {
        return;
    }

    s_adc_ready = false;
    zone_monitor_compute_measurements(now_ms);
}

bool zone_monitor_pop_event(zone_event_t *event_out)
{
    if (!event_out || queue_is_empty()) {
        return false;
    }

    *event_out = s_event_queue[s_event_tail];
    s_event_tail = queue_increment(s_event_tail);
    return true;
}

zone_state_t zone_monitor_get_reported_state(uint8_t zone_id)
{
    if (zone_id >= ZONE_MONITOR_ZONE_COUNT) {
        return ZONE_STATE_FAULT_OPEN;
    }
    return s_zones[zone_id].reported_state;
}

zone_state_t zone_monitor_get_physical_state(uint8_t zone_id)
{
    if (zone_id >= ZONE_MONITOR_ZONE_COUNT) {
        return ZONE_STATE_FAULT_OPEN;
    }
    return s_zones[zone_id].physical_state;
}

uint8_t zone_monitor_get_alarm_bitmap(void)
{
    return s_alarm_bitmap;
}

uint8_t zone_monitor_get_short_bitmap(void)
{
    return s_short_bitmap;
}

uint8_t zone_monitor_get_open_bitmap(void)
{
    return s_open_bitmap;
}

uint8_t zone_monitor_get_tamper_bitmap(void)
{
    return s_tamper_bitmap;
}

uint8_t zone_monitor_get_present_bitmap(void)
{
    return s_present_bitmap;
}

uint8_t zone_monitor_get_legacy_bitmap(void)
{
    return s_legacy_bitmap;
}

float zone_monitor_get_vdda(void)
{
    return s_vdda;
}

float zone_monitor_get_vbias(void)
{
    return s_vbias;
}

float zone_monitor_get_temperature_c(void)
{
    return s_temperature_c;
}

bool zone_monitor_vbias_warning(void)
{
    return s_vbias_warning;
}

bool zone_monitor_contact_is_no(void)
{
    return (s_cfg.contact == ZONE_CONTACT_NO);
}

zone_mode_t zone_monitor_get_mode(void)
{
    return s_cfg.mode;
}

uint16_t zone_monitor_get_zone_raw(uint8_t zone_id)
{
    if (zone_id >= ZONE_MONITOR_ZONE_COUNT) {
        return 0u;
    }
    return s_zones[zone_id].raw_adc;
}

float zone_monitor_get_zone_rloop(uint8_t zone_id)
{
    if (zone_id >= ZONE_MONITOR_ZONE_COUNT) {
        return 0.0f;
    }
    return s_zones[zone_id].rloop_ohm;
}

void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef *hadc)
{
    (void)hadc;
}

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)
{
    if (hadc != s_adc_handle) {
        return;
    }

    for (uint32_t channel = 0u; channel < ADC_CHANNEL_COUNT; ++channel) {
        uint32_t sum = 0u;
        for (uint32_t sample = 0u; sample < ADC_SAMPLE_COUNT; ++sample) {
            sum += s_adc_buffer[(sample * ADC_CHANNEL_COUNT) + channel];
        }
        s_adc_average[channel] = (uint16_t)(sum / ADC_SAMPLE_COUNT);
    }

    s_adc_ready = true;
}

static void zone_monitor_reset_states(void)
{
    memset(s_zones, 0, sizeof(s_zones));
    s_alarm_bitmap = 0u;
    s_short_bitmap = 0u;
    s_open_bitmap = 0u;
    s_tamper_bitmap = 0u;
    s_present_bitmap = 0u;
    s_legacy_bitmap = 0u;
    s_event_head = 0u;
    s_event_tail = 0u;
    s_event_seq = 0u;

    for (uint8_t i = 0u; i < ZONE_MONITOR_ZONE_COUNT; ++i) {
        s_zones[i].physical_state = ZONE_STATE_FAULT_OPEN;
        s_zones[i].reported_state = zone_monitor_apply_contact(ZONE_STATE_FAULT_OPEN);
        s_zones[i].pending_state = s_zones[i].physical_state;
        s_zones[i].pending_since = 0u;
        s_zones[i].raw_adc = 0u;
        s_zones[i].rloop_ohm = 0.0f;
        s_zones[i].present = false;
    }
}

static void zone_monitor_push_event(const zone_event_t *event)
{
    if (!event) {
        return;
    }

    uint8_t next_head = queue_increment(s_event_head);
    if (next_head == s_event_tail) {
        s_event_tail = queue_increment(s_event_tail);
    }

    s_event_queue[s_event_head] = *event;
    s_event_head = next_head;
}

static zone_state_t zone_monitor_apply_contact(zone_state_t physical)
{
    if (s_cfg.contact != ZONE_CONTACT_NO) {
        return physical;
    }

    switch (physical) {
    case ZONE_STATE_NORMAL:
        return ZONE_STATE_ALARM;
    case ZONE_STATE_ALARM:
        return ZONE_STATE_NORMAL;
    default:
        return physical;
    }
}

static zone_state_t zone_monitor_classify(zone_state_t previous, float rloop, bool fault_short, bool fault_open, float vz, float vbias)
{
    (void)vz;
    (void)vbias;

    if (fault_short) {
        return ZONE_STATE_FAULT_SHORT;
    }
    if (fault_open) {
        return ZONE_STATE_FAULT_OPEN;
    }

    if (s_cfg.mode == ZONE_MODE_EOL1_SERIE) {
        return zone_monitor_classify_eol1(previous, rloop, fault_short, fault_open);
    }

    return zone_monitor_classify_banded(previous, rloop, fault_short, fault_open);
}

static zone_state_t zone_monitor_classify_eol1(zone_state_t previous, float rloop, bool fault_short, bool fault_open)
{
    (void)fault_short;
    (void)fault_open;

    float center = ZONE_R_EOL_SERIES_OHM;
    float stay_low = center * (1.0f - ZONE_TOL_EOL1 - ZONE_HYSTERESIS_PCT);
    if (stay_low < 0.0f) {
        stay_low = 0.0f;
    }
    float stay_high = center * (1.0f + ZONE_TOL_EOL1 + ZONE_HYSTERESIS_PCT);
    float enter_high = center * (1.0f + ZONE_TOL_EOL1);

    if ((previous == ZONE_STATE_NORMAL) && (rloop >= stay_low) && (rloop <= stay_high)) {
        return ZONE_STATE_NORMAL;
    }

    if (rloop <= enter_high) {
        return ZONE_STATE_NORMAL;
    }

    return ZONE_STATE_ALARM;
}

static const zone_band_t *zone_monitor_get_bands(size_t *count)
{
    static const zone_band_t eol2_bands[] = {
        { ZONE_STATE_NORMAL, ZONE_R_NORMAL_OHM, ZONE_TOL_NORMAL },
        { ZONE_STATE_ALARM,  ZONE_R_NORMAL_OHM + ZONE_R_ALARM_OHM, ZONE_TOL_ALARM },
    };

    static const zone_band_t eol3_bands[] = {
        { ZONE_STATE_NORMAL, ZONE_R_NORMAL_OHM, ZONE_TOL_NORMAL },
        { ZONE_STATE_ALARM,  ZONE_R_NORMAL_OHM + ZONE_R_ALARM_OHM, ZONE_TOL_ALARM },
        { ZONE_STATE_TAMPER, ZONE_R_NORMAL_OHM + ZONE_R_TAMPER_OHM, ZONE_TOL_TAMPER },
    };

    if (s_cfg.mode == ZONE_MODE_EOL3) {
        if (count) {
            *count = sizeof(eol3_bands) / sizeof(eol3_bands[0]);
        }
        return eol3_bands;
    }

    if (count) {
        *count = sizeof(eol2_bands) / sizeof(eol2_bands[0]);
    }
    return eol2_bands;
}

static zone_state_t zone_monitor_classify_banded(zone_state_t previous, float rloop, bool fault_short, bool fault_open)
{
    (void)fault_short;
    (void)fault_open;

    size_t band_count = 0u;
    const zone_band_t *bands = zone_monitor_get_bands(&band_count);

    const zone_band_t *previous_band = NULL;
    for (size_t i = 0u; i < band_count; ++i) {
        if (bands[i].state == previous) {
            previous_band = &bands[i];
            break;
        }
    }

    if (previous_band != NULL) {
        float stay_low = previous_band->center_ohm * (1.0f - previous_band->tolerance - ZONE_HYSTERESIS_PCT);
        if (stay_low < 0.0f) {
            stay_low = 0.0f;
        }
        float stay_high = previous_band->center_ohm * (1.0f + previous_band->tolerance + ZONE_HYSTERESIS_PCT);
        if ((rloop >= stay_low) && (rloop <= stay_high)) {
            return previous_band->state;
        }
    }

    for (size_t i = 0u; i < band_count; ++i) {
        float enter_low = bands[i].center_ohm * (1.0f - bands[i].tolerance);
        float enter_high = bands[i].center_ohm * (1.0f + bands[i].tolerance);
        if ((rloop >= enter_low) && (rloop <= enter_high)) {
            return bands[i].state;
        }
    }

    const zone_band_t *closest = bands;
    float min_diff = fabsf(rloop - bands[0].center_ohm);
    for (size_t i = 1u; i < band_count; ++i) {
        float diff = fabsf(rloop - bands[i].center_ohm);
        if (diff < min_diff) {
            min_diff = diff;
            closest = &bands[i];
        }
    }
    return closest->state;
}

static void zone_monitor_recompute_bitmaps(void)
{
    uint8_t alarm = 0u;
    uint8_t short_bm = 0u;
    uint8_t open_bm = 0u;
    uint8_t tamper_bm = 0u;
    uint8_t present_bm = 0u;
    uint8_t legacy_bm = 0u;

    for (uint8_t i = 0u; i < ZONE_MONITOR_ZONE_COUNT; ++i) {
        zone_state_t phys = s_zones[i].physical_state;
        zone_state_t reported = s_zones[i].reported_state;

        if (phys == ZONE_STATE_FAULT_SHORT) {
            short_bm |= (1u << i);
        }
        if (phys == ZONE_STATE_FAULT_OPEN) {
            open_bm |= (1u << i);
        }
        if (phys == ZONE_STATE_TAMPER) {
            tamper_bm |= (1u << i);
        }
        if (reported == ZONE_STATE_ALARM) {
            alarm |= (1u << i);
        }
        if (phys != ZONE_STATE_FAULT_SHORT && phys != ZONE_STATE_FAULT_OPEN) {
            present_bm |= (1u << i);
        }
        if (reported == ZONE_STATE_ALARM) {
            legacy_bm |= (1u << i);
        }
    }

    s_alarm_bitmap = alarm;
    s_short_bitmap = short_bm;
    s_open_bitmap = open_bm;
    s_tamper_bitmap = tamper_bm;
    s_present_bitmap = present_bm;
    s_legacy_bitmap = legacy_bm;
}

static void zone_monitor_handle_state_update(uint8_t zone_id, uint32_t now_ms, float vz, bool fault_short, bool fault_open, float rloop, uint16_t raw)
{
    zone_runtime_t *zone = &s_zones[zone_id];

    zone->raw_adc = raw;
    zone->rloop_ohm = rloop;
    zone->present = !(fault_short || fault_open);

    zone_state_t previous_physical = zone->physical_state;
    zone_state_t candidate_physical = zone_monitor_classify(zone->physical_state, rloop, fault_short, fault_open, vz, s_vbias);

    if (candidate_physical == zone->physical_state) {
        zone->pending_state = candidate_physical;
        zone->pending_since = now_ms;
    } else {
        if (zone->pending_state != candidate_physical) {
            zone->pending_state = candidate_physical;
            zone->pending_since = now_ms;
        } else {
            uint32_t elapsed = now_ms - zone->pending_since;
            if (elapsed >= ZONE_DEBOUNCE_MS) {
                zone->physical_state = candidate_physical;
                zone_state_t previous_reported = zone->reported_state;
                zone->reported_state = zone_monitor_apply_contact(zone->physical_state);

                if ((zone->physical_state != previous_physical) || (zone->reported_state != previous_reported)) {
                    zone_event_t event = {
                        .zone_id = zone_id,
                        .physical_state = zone->physical_state,
                        .reported_state = zone->reported_state,
                        .present = zone->present,
                        .raw_adc = raw,
                        .rloop_ohm = rloop,
                        .vbias_volt = s_vbias,
                        .sequence = s_event_seq++,
                    };
                    zone_monitor_push_event(&event);
                }
            }
        }
    }
}

static void zone_monitor_compute_measurements(uint32_t now_ms)
{
    uint16_t raw_vref = s_adc_average[ADC_INDEX_VREF];
    if (raw_vref != 0u) {
        s_vdda = (1.20f * 4095.0f) / (float)raw_vref;
    }

    uint16_t raw_temp = s_adc_average[ADC_INDEX_TEMP];
    float vsense = ((float)raw_temp * s_vdda) / 4095.0f;
    s_temperature_c = ((TEMP_SENSOR_V25 - vsense) / TEMP_SENSOR_SLOPE) + 25.0f;

    uint16_t raw_vbias = s_adc_average[ADC_INDEX_VBIAS];
    s_vbias = ((float)raw_vbias * s_vdda / 4095.0f) * 11.0f;
    s_vbias_warning = (s_vbias < 8.0f) || (s_vbias > 16.0f);

    for (uint8_t zone_id = 0u; zone_id < ZONE_MONITOR_ZONE_COUNT; ++zone_id) {
        uint16_t raw = s_adc_average[zone_id];
        float v_adc = ((float)raw * s_vdda) / 4095.0f;
        float vz = v_adc * 5.545f;

        bool fault_short_voltage = (vz < 0.05f);
        bool fault_open_voltage = (s_vbias > 0.0f) ? (vz > (0.95f * s_vbias)) : true;

        float denominator = s_vbias - vz;
        float rloop = 0.0f;
        if (denominator <= 0.0f || s_vbias <= 0.0f) {
            rloop = ZONE_OPEN_THRESHOLD_OHM + 1.0f;
        } else {
            rloop = (vz * 6800.0f) / denominator;
        }

        bool fault_short_res = (rloop < ZONE_SHORT_THRESHOLD_OHM);
        bool fault_open_res = (rloop > ZONE_OPEN_THRESHOLD_OHM);

        bool fault_short = fault_short_voltage || fault_short_res;
        bool fault_open = fault_open_voltage || fault_open_res;

        zone_monitor_handle_state_update(zone_id, now_ms, vz, fault_short, fault_open, rloop, raw);
    }

    zone_monitor_recompute_bitmaps();
}

static void zone_monitor_blink_mode(zone_mode_t mode, zone_contact_t contact)
{
    uint32_t short_count = 1u;
    switch (mode) {
    case ZONE_MODE_EOL1_SERIE:
        short_count = 1u;
        break;
    case ZONE_MODE_EOL2:
        short_count = 2u;
        break;
    case ZONE_MODE_EOL3:
        short_count = 3u;
        break;
    default:
        short_count = 2u;
        break;
    }

    for (uint32_t i = 0u; i < short_count; ++i) {
        HAL_GPIO_WritePin(STATUS_LED_GPIO_Port, STATUS_LED_Pin, GPIO_PIN_RESET);
        HAL_Delay(ZONE_LED_SHORT_BLINK_MS);
        HAL_GPIO_WritePin(STATUS_LED_GPIO_Port, STATUS_LED_Pin, GPIO_PIN_SET);
        HAL_Delay(ZONE_LED_SHORT_PAUSE_MS);
    }

    if (contact == ZONE_CONTACT_NO) {
        HAL_GPIO_WritePin(STATUS_LED_GPIO_Port, STATUS_LED_Pin, GPIO_PIN_RESET);
        HAL_Delay(ZONE_LED_LONG_BLINK_MS);
        HAL_GPIO_WritePin(STATUS_LED_GPIO_Port, STATUS_LED_Pin, GPIO_PIN_SET);
        HAL_Delay(ZONE_LED_AFTER_PAUSE_MS);
    }
}
